"""
File Handlers - Built-in handlers for common file formats

This module provides handlers for extracting text content from various file types.
For unknown formats, the ClaudeHandlerGenerator can create custom handlers on-the-fly.
"""

from pathlib import Path
from typing import Optional
import logging

from .base import BaseHandler
from .pdf import PDFHandler, PDFWithOCRHandler
from .docx import DocxHandler, LegacyDocHandler
from .xlsx import XLSXHandler, XLSHandler
from .csv import CSVHandler, FixedWidthHandler
from .image import ImageHandler, ScreenshotHandler
from .email import EmailHandler, MSGHandler
from .xml import XMLHandler, HTMLHandler, JSONHandler
from .p360_syndication_handler import P360SyndicationHandler

logger = logging.getLogger(__name__)

# Advanced handlers (require API keys)
try:
    from .image_vision import ImageVisionHandler
    VISION_AVAILABLE = True
except ImportError:
    VISION_AVAILABLE = False
    logger.warning("ImageVisionHandler not available")

try:
    from .step_handler import STPHandler
    STEP_AVAILABLE = True
except ImportError:
    STEP_AVAILABLE = False
    logger.warning("STPHandler not available")

# Registry of built-in handlers
# Priority: Specific handlers > generic handlers
# P360SyndicationHandler must come BEFORE XMLHandler (more specific)
_BUILT_IN_HANDLERS = [
    P360SyndicationHandler(),  # EATON syndication XML (must be before XMLHandler)
    PDFHandler(),
    DocxHandler(),
    LegacyDocHandler(),
    XLSXHandler(),
    XLSHandler(),
    CSVHandler(),
    EmailHandler(),
    MSGHandler(),
    XMLHandler(),  # Generic XML (fallback)
    HTMLHandler(),
    JSONHandler(),
]

# Add Vision handler if available (takes priority over basic ImageHandler)
if VISION_AVAILABLE:
    import os
    if os.getenv("OPENAI_API_KEY"):
        _BUILT_IN_HANDLERS.insert(0, ImageVisionHandler())  # High priority
        logger.info("✓ ImageVisionHandler enabled (OpenAI Vision API)")
    else:
        _BUILT_IN_HANDLERS.append(ImageHandler())  # Fallback
        logger.info("ImageHandler fallback (no OpenAI key)")
else:
    _BUILT_IN_HANDLERS.append(ImageHandler())

# Add STEP handler if available
if STEP_AVAILABLE:
    _BUILT_IN_HANDLERS.append(STPHandler())
    logger.info("✓ STPHandler enabled (3D CAD models)")
else:
    _BUILT_IN_HANDLERS.append(ScreenshotHandler())

# Registry for custom (Claude-generated) handlers
_CUSTOM_HANDLERS = {}


def get_handler(file_path: Path) -> Optional[BaseHandler]:
    """
    Get appropriate handler for a file.

    Priority:
    1. Custom handlers (Claude-generated for specific patterns)
    2. Built-in handlers (by extension)

    Args:
        file_path: Path to file

    Returns:
        Handler instance, or None if no handler available
    """
    extension = file_path.suffix.lower()

    # Check custom handlers first (more specific)
    if extension in _CUSTOM_HANDLERS:
        return _CUSTOM_HANDLERS[extension]

    # Check built-in handlers
    for handler in _BUILT_IN_HANDLERS:
        if handler.can_handle(file_path):
            return handler

    logger.debug(f"No handler found for {extension} ({file_path.name})")
    return None


def register_custom_handler(extension: str, handler: BaseHandler):
    """
    Register a custom handler (e.g., generated by Claude).

    Args:
        extension: File extension (e.g., '.datev')
        handler: Handler instance
    """
    extension = extension.lower()
    if not extension.startswith('.'):
        extension = '.' + extension

    _CUSTOM_HANDLERS[extension] = handler
    logger.info(f"Registered custom handler for {extension}: {handler.__class__.__name__}")


def get_supported_extensions() -> set[str]:
    """
    Get all supported file extensions.

    Returns:
        Set of extensions (e.g., {'.pdf', '.docx', ...})
    """
    extensions = set()

    # Built-in handlers
    for handler in _BUILT_IN_HANDLERS:
        try:
            # Try calling as classmethod
            exts = handler.__class__.supported_extensions()
            if isinstance(exts, set):
                extensions.update(exts)
            elif isinstance(exts, list):
                extensions.update(set(exts))
        except TypeError:
            # If it's a property or instance method, access directly
            try:
                exts = handler.supported_extensions
                if callable(exts):
                    exts = exts()
                if isinstance(exts, (set, list)):
                    extensions.update(set(exts) if isinstance(exts, list) else exts)
            except Exception as e:
                logger.warning(f"Could not get extensions from {handler}: {e}")

    # Custom handlers
    extensions.update(_CUSTOM_HANDLERS.keys())

    return extensions


def list_handlers() -> dict[str, str]:
    """
    List all available handlers.

    Returns:
        Dictionary mapping extension to handler name
    """
    handlers = {}

    # Built-in
    for handler in _BUILT_IN_HANDLERS:
        for ext in handler.supported_extensions():
            handlers[ext] = f"{handler.__class__.__name__} (built-in)"

    # Custom
    for ext, handler in _CUSTOM_HANDLERS.items():
        handlers[ext] = f"{handler.__class__.__name__} (custom)"

    return handlers


__all__ = [
    'BaseHandler',
    'PDFHandler',
    'PDFWithOCRHandler',
    'DocxHandler',
    'LegacyDocHandler',
    'XLSXHandler',
    'XLSHandler',
    'CSVHandler',
    'FixedWidthHandler',
    'ImageHandler',
    'ScreenshotHandler',
    'EmailHandler',
    'MSGHandler',
    'XMLHandler',
    'HTMLHandler',
    'JSONHandler',
    'get_handler',
    'register_custom_handler',
    'get_supported_extensions',
    'list_handlers',
]
